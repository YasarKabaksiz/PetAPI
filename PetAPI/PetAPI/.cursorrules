Her zaman SOLID prensiplerini göz önünde bulundur. Özellikle Tek Sorumluluk Prensibi (Single Responsibility) ve Bağımlılığın Tersine Çevrilmesi (Dependency Inversion) prensiplerine sıkı sıkıya bağlı kal.Her zaman SOLID prensiplerini göz önünde bulundur. Özellikle Tek Sorumluluk Prensibi (Single Responsibility) ve Bağımlılığın Tersine Çevrilmesi (Dependency Inversion) prensiplerine sıkı sıkıya bağlı kal.
Veritabanı erişimi ve iş mantığı (business logic) asla Controller katmanında yer almamalıdır. Tüm bu işlemler, Services klasöründeki servis sınıflarında (PetService, UserService vb.) ve bu sınıfların arayüzleri (IPetService) aracılığıyla yapılmalıdır. Controller'lar sadece HTTP isteklerini alıp ilgili servisi çağırmak ve cevabı HTTP formatına dönüştürmekle görevlidir.
API'nin dış dünya ile iletişime geçtiği her noktada DTO'lar kullanılacaktır. Entity sınıfları (User, Pet) asla API sınırlarının dışına çıkmamalıdır. İstekler için ...CreateDto, ...UpdateDto; yanıtlar için ...ViewDto gibi isimlendirme standartları kullanılacaktır. Veri doğrulama (Data Annotations) sadece DTO'lar üzerinde yapılmalıdır.
Veritabanı erişimi, dosya işlemleri veya herhangi bir I/O işlemi içeren tüm metotlar istisnasız olarak async olmalı ve await ile çağrılmalıdır. Metot isimleri ...Async sonekiyle bitmelidir (örn: GetPetByIdAsync).
Tüm değişkenler, metotlar, sınıflar ve arayüzler için standart .NET isimlendirme kurallarına uy. (camelCase yerel değişkenler için, PascalCase diğer her şey için, arayüzler için I öneki vb.).
x, temp, data gibi anlamsız isimler yerine, değişkenin veya metodun amacını açıkça belirten isimler kullan (petToFeed, GetAllActiveUsersAsync).
Kodun "ne yaptığını" değil, "neden yaptığını" açıklayan yorumlar ekle. Karmaşık bir algoritma veya standart dışı bir çözüm varsa, nedenini mutlaka bir yorum satırıyla belirt.
Tüm dosyaların doğru namespace içinde olduğundan ve gereksiz using ifadelerinin kaldırıldığından emin ol.
Entity Framework Core zaten bunu otomatik yapar, ancak ham SQL sorguları yazman gerekirse, SQL Injection saldırılarını önlemek için mutlaka parametreli sorgular kullan.
API yanıtlarında asla PasswordHash gibi hassas verileri döndürme. Yanıt DTO'ları bu tür verileri içermemelidir.
[Authorize] attribute'u varsayılan olarak tüm hassas controller'lara uygulanmalıdır. Gerekirse, metot bazında [AllowAnonymous] veya rol bazlı yetkilendirme ([Authorize(Roles = "Admin")]) kullanılabilir. Bir kullanıcının sadece kendi verilerine erişebildiğinden emin ol (örn: "get my pet" endpoint'i, JWT'den gelen kullanıcı ID'sini kullanarak doğru hayvanı getirmelidir).
Tüm kullanıcı girdilerini (DTO'lar aracılığıyla) hem tür hem de içerik olarak doğrula. Beklenmedik girdilere karşı sistemi koru.
Beklenmedik hatalar için oluşturduğumuz GlobalExceptionHandlerMiddleware kullanılacaktır. Servis katmanında bilerek ve isteyerek fırlatılan özel exception'lar (örn: PetNotFoundException) dışında, try-catch bloklarını minimumda tut.
Kullanıcıya dönen hata mesajları, sistemin iç yapısını ifşa etmemeli ancak sorunu anlayabileceği kadar bilgi vermelidir. "Object reference not set to an instance of an object" gibi hatalar kullanıcıya asla gösterilmemelidir.
Tüm önemli olaylar (bir işlemin başlangıcı/bitişi, önemli kararlar) ve özellikle tüm hatalar, Serilog kullanılarak yapısal bir formatta loglanmalıdır. Log mesajları, sorunu teşhis etmek için yeterli bağlamı (context) içermelidir (örn: hangi kullanıcı, hangi metotta, hangi veriyle hata aldı).
Gereksiz yere tüm tabloyu çekmekten kaçın. Where, Select gibi ifadelerle sorguyu veritabanı tarafında filtrele. Select kullanarak sadece ihtiyaç duyulan kolonları çek (AutoMapper veya manuel mapping ile DTO'lara dönüştür).
Döngü içinde veritabanı sorgusu yapmaktan kaçın. Gerektiğinde Include veya ThenInclude kullanarak ilişkili verileri tek bir sorguda verimli bir şekilde çek.
Sadece veri okuma işlemi yapılan sorgularda (GET istekleri), performansı artırmak için .AsNoTracking() metodunu kullan.
